# 小型分布式图书馆系统的数据库系统

### 一.需求分析

1. **数据存储要求**
   - 数据必须存储在至少3个物理站点上，以确保数据的高可用性和容错性。
   - 数据的存储和分布方式对用户完全透明，不会影响用户的操作和体验。
2. **查询支持**
   - 系统支持基本的SQL查询语句，重点支持CRUD（创建、读取、更新、删除）等基本操作。
   - 系统不强制支持嵌套查询语句，专注于常用的简单SQL语句的执行。
   - 查询结果应能够实时反映到用户界面，确保用户可以及时获取查询结果。
3. **数据分片支持**
   - 系统支持多种数据划分方式：
     - **水平划分**：根据行数据的不同范围将数据划分到不同站点。
     - **垂直划分**：根据列属性划分数据。
     - **水平 + 垂直混合划分**：组合水平和垂直划分的方式。
     - **混合划分**：灵活支持其他划分策略，以满足特定场景需求。
   - 系统可以根据实际需求，灵活选择或调整数据的分布方式，以提高查询效率和系统性能。
4. **查询分解与优化**
   - 用户的查询请求必须经过解析与优化，并分解成可分布执行的子任务。
   - 优化后的查询会下发给底层数据库管理系统进行分布式执行，以提高查询的性能和准确性。
5. **分站点服务器界面**
   - 各分站点服务器的界面上必须实时显示接收和发送的SQL命令，直观展示命令的执行过程。
   - 命令的执行结果和处理过程直接在界面显示，不允许将这些信息记录到日志文件中，以确保信息的实时性和可视化。
6. **主站点界面**
   - 主站点界面应显示用户查询的分解和优化过程，确保用户可以直观了解查询的执行流程。
   - 主站点同时承担系统协调和调度的任务，提供对查询优化过程的实时反馈。

### 二. 系统结构设计

#### 2.1 总体设计

​	本系统采用Java 17编写，并基于Spring Boot框架实现分布式通信，通过HTTP协议实现各站点之间的交互。系统使用B+树作为数据存储结构，主站点和各分站点均独立维护本地的B+树，以实现数据的高效存储与快速检索。查询请求首先由主站点接收并解析，主站点利用全局索引将请求分解为子查询，然后通过Spring Boot的HTTP接口将子查询分发到相应分站点。
​	在各分站点中，Spring Boot的Controller组件负责接收并处理主站点发来的HTTP请求，调用本地B+树进行数据操作，并将结果通过HTTP返回给主站点。主站点负责汇总各分站点的结果并返回给用户，从而实现透明、快速的分布式数据查询。


#### 2.2 数据存储设计
​	本系统采用B+树作为底层数据存储结构，利用其高效的检索和范围查询能力，实现对大规模有序数据的管理。B+树的叶子节点存储实际数据，并按顺序相连，适合快速的范围查询操作。在分布式环境中，数据根据B+树的键值范围进行分片，分布在多个站点的本地B+树中，各站点各自维护本地B+树的结构与索引。
​	在分布式架构中，通过HTTP协议在站点之间进行通信，主站点负责全局索引的管理及查询请求的路由。用户查询请求在主站点通过全局B+树索引解析后，拆分成多个子查询，并由HTTP请求发送至相关分站点进行处理。各分站点基于本地B+树结构独立执行查询，返回结果至主站点汇总。主站点还负责协调各站点间的数据一致性与故障恢复，确保分布式系统的高可用性和数据可靠性。

#### 2.3 查询设计

​	本系统采用基于ANTLR4解析框架实现SQL查询语句解析，首先通过在ANTLR4中定义SQL语法文件，包括词法规则：定义 SQL 语句中的基本元素这些规则会成为解析树的叶节点、语法规则：定义 SQL 的语法结构，即不同语句的组成方式和顺序；确保ANTLR4 能识别并解析 SQL 语句的基本结构，接着通过 ANTLR4 工具根据定义的SQL语法生成词法解析器和语法解析器，词法解析器负责分解 SQL 语句的基本元素，语法解析器负责将这些元素组合成符合 SQL 语法的结构。从而在程序中使用解析器解析输入的 SQL 语句，生成对应的解析树。接着采用 ANTLR4 提供的 Listener模式，遍历解析树的各个节点，提取所需的信息（如列名、表名、条件等），为后续逻辑执行计划的生成提供基础。最后对解析结果进行分析，利用经典火山模型生成 SQL 逻辑执行计划。生成的执行计划详细描述了 SQL 语句的执行步骤，并可以应用优化规则谓词下推以提升执行效率。

### 2.4 数据分片支持

#### 2.5查询分解和优化 

​	本系统基于查询设计中ANTLR4解析框架实现，查询分解是将复杂的 SQL 查询语句逐步分解为更简单的、可处理的子部分，便于进一步优化和执行。首先，使用 ANTLR4 定义 SQL 查询的语法规则，这些规则包括 SQL 的各类查询、选择、过滤、连接等操作，并利用 ANTLR4 生成的语法解析器来解析 SQL 查询字符串。解析器将 SQL 查询转化为抽象语法树（AST）或解析树。这个过程可以得到查询的结构信息通过ANTLR4工具生成的 **Listener** 模式遍历解析树，分析各个子句和查询元素。

​	查询优化是在查询分解的基础上，对分解后的查询子部分应用各种优化策略，生成更高效的执行计划，这里我们在ANTLR4生成的抽象语法树基础上进行谓词下推的逻辑优化，在 解析得到的SQL 查询中定位 WHERE、JOIN等子句中的过滤条件（谓词）尽可能“下推”到数据源的早期处理步骤中，从而减少不必要的数据传输和计算，降低查询的执行成本。

#### 2.6界面设计

### 三. 详细设计！！

#### 3.1 数据存储结构设计

#### 3.2 查询设计

​	为了支持用户的基本 SQL 查询，解析SQL查询语句是必须的，SQL解析功能是数据库管理系统中的一个关键组件，它负责解释和分析用户提交的SQL查询语句，通过SQL解析，DBMS能够理解用户的请求并执行相应的操作，如查询、插入、更新或删除数据。 

​	解析 SQL 语句的首要目的是理解用户的查询意图，即了解用户希望从数据库中提取哪些信息。通过解析 SQL，可以将用户的自然语言式查询转换为数据库系统可以理解和处理的结构。解析过程能够检测 SQL 语句的语法错误。如果用户的查询语句中存在拼写错误或格式错误，解析器会在执行前捕获这些错误，并向用户返回明确的错误信息。SQL 解析后可以生成一个逻辑执行计划，展示查询语句的执行步骤。这对于优化查询性能至关重要。通过解析语句，可以分解查询的各个部分，并安排最优的执行顺序。解析 SQL 查询后，可以应用优化策略，如逻辑优化、物理优化。这些优化可以提升查询的执行效率，减少资源消耗，尤其在处理大数据时更为关键。

​	在 Java 生态中，现有多个 SQL 解析框架，每个框架在功能、使用场景和易用性上有所不同。jOOQ：jOOQ 是一个面向对象的 SQL 查询构建库，旨在通过 Java 代码生成和执行 SQL 查询。它也有一定的 SQL 解析能力，jOOQ 更侧重于生成和执行 SQL 查询，SQL 解析功能相对较弱，主要是为构建 SQL 提供方便。如果更关注 SQL 查询的构建和执行而不是 SQL 解析，jOOQ 是非常适合的，它能够简化代码并减少 SQL 错误。

​	SQLParser：SQLParser 是一个轻量级的 SQL 解析器，专门用于解析 SQL 语句，支持多种 SQL 语法，相比于 ANTLR 的功能较为简单，缺乏深入的查询优化能力。适用于简单的 SQL 解析需求，不需要复杂的语法或优化，只是想快速解析并处理 SQL 语句的场景。

​	ANTLR4：ANTLR 是一个强大的语法分析器生成器，它允许你使用自定义的语法规则来定义语言结构，包括 SQL 语法。它可以生成解析器（parser），将输入的 SQL 语句解析为抽象语法树（AST）或解析树，这对于后续的查询优化、执行计划生成等操作非常重要。可以在解析后方便地对查询结构进行深度分析和优化，ANTLR4 的解析树可以与自定义的查询优化算法（如谓词下推、连接重排序等）结合，实现复杂的查询优化功能。这使得能够从根本上优化 SQL 查询性能。

​	Google 的开源项目如 Bazel构建工具就使用了 ANTLR4 来解析配置文件和构建规则，Apache Calcite 本身也使用了 ANTLR4 来解析 SQL 查询，并支持复杂的查询优化和执行计划生成。

​	对比现有的几个SQL解析框架，考虑到ANTLR4允许完全自定义 SQL 语法，提供了极大的灵活性，且提供了大量的使用的语法文档，并能够生成抽象语法树，这对于后续的查询优化、执行计划生成等操作非常重要。可以在解析后方便地对查询结构进行深度分析和优化；我们选择了ANTLR4作为SQL解析框架。使用 ANTLR4 实现 SQL 语句解析的设计步骤简化为：定义 SQL 语法规则、使用 ANTLR4 生成解析器、构建解析树并处理错误、遍历解析树、生成逻辑执行计划。

![pAyvVgO.png](https://s21.ax1x.com/2024/11/08/pAyvVgO.png)



##### 3.2.1 定义 SQL 语法规则

​	定义 SQL 语法规则的主要目的是为了确保 SQL 查询能够被正确解析和理解，进而实现对 SQL 语句的执行、优化和改写。SQL 作为一种标准的查询语言，它的语法非常严格，必须按照特定规则书写才能被数据库管理系统正确执行。SQL 查询语句在不同的数据库系统中都需要遵循相同的基本语法规则，确保不同的 SQL 查询在不同数据库系统之间能够被统一解析和处理。SQL 查询解析器需要根据预先定义的语法规则将输入的查询语句转化为计算机可以处理的内部数据结构（如抽象语法树 AST）。没有明确的语法规则，解析器就无法理解 SQL 查询的结构。定义清晰的 SQL 语法规则有助于 SQL 查询的优化过程，数据库系统可以基于这些规则对查询进行优化，生成更高效的执行计划。SQL 语法规则可以帮助数据库系统在查询执行前检测 SQL 语句的语法错误，避免错误的查询语句进入数据库执行阶段。

​	SQL 语法规则决定了如何将 SQL 查询拆解为更小的、可以理解的部分，并为解析器提供了规则和方法来识别并正确构建语法树。SQL 语法规则提供了一种验证机制，通过检查 SQL 查询是否符合规则，数据库能够提前识别潜在的语法错误，并为用户提供详细的错误信息。SQL 语法规则为 AST 的生成提供了必要的指导，帮助将查询转化为数据库引擎可以理解和执行的内部结构。SQL 语法规则对于查询优化至关重要，例如，某些语法结构可能会提示数据库优化某些查询操作（例如，将过滤条件下推到最早的扫描步骤，或者将某些查询转化为更高效的等价查询）。数据库系统通过分析查询的语法结构，能够识别并应用这些优化策略。

​	在使用 ANTLR4 进行语法解析时，定义语法规则是核心步骤。ANTLR4 语法规则是通过 .g4文件定义的。这些文件包含了语言的语法规则、词法规则和解析规则。在 .g4文件中，语法规则通过以下几种方式定义：**词法规则（Lexer Rules）**：用于定义输入文本中的词汇单位（tokens）构成了SQL查询语句的基本单位。**语法规则（Parser Rules）**：用于定义语法的结构。规则的名称通常以小写字母开头。这里我们给出一个简单的SQL语法文件的定义，它描述了一个简单的SELECT查询语句的结构。

``` antlr
// SQLParser.g4

grammar SQLParser;

selectStatement : 'SELECT' columnList 'FROM' tableName whereClause?;

columnList      : '*' | columnName (',' columnName)*;

columnName      : identifier;

tableName       : identifier;

whereClause     : 'WHERE' condition;

condition       : columnName comparisonOperator value;

comparisonOperator : '=' | '!=' | '>' | '<' | '>=' | '<=';

value           : number | string | identifier;

identifier      : [a-zA-Z][a-zA-Z0-9_]*;

number          : [0-9]+;

string          : '\'' [a-zA-Z0-9]+ '\'';
```

在这个例子中，`identifier`和 `number`是词法规则，用来匹配 SQL 查询中的标识符（列名、表名等）和数字；`selectStatement`和 `columnList` 是语法规则，描述 SQL 查询的不同结构部分。

​	这里我们使用了ANTLR4官方提供的Mysql定义使用的sqlbase.g4语法文件，Mysql定义的语法文件支持多种 SQL 特性和方言，些语法规则会涵盖 SQL 的各个方面，并且包含了许多 MySQL 特有的语法扩展。

##### 3.2.2 使用ANTLR4生成解析器

词法分析器（`Lexer`）：词法分析器的主要任务是将输入的SQL查询语句根据定义的.g4语法文件的词法规则拆分成一系列 **标记（Token）**。每个标记是源代码中最小的有意义单元。

语法解析器（`Parser`）：语法分析器的主要任务是将词法分析器生成的 Token流按照预定义的语法规则进行解析，构建出 **抽象语法树（AST）**。AST反映了SQL查询语句中的语法结构，展示了语言元素之间的层次关系。语法分析器根据定义的语法规则来识别 Token 序列是否符合.g4语法结构。如果符合规则，语法分析器会将其构建成AST树。



抽象语法树（`AST`）：抽象语法树是一种树状数据结构，用于表示源代码或查询的语法结构。在 SQL 查询解析的上下文中，AST 是由 SQL 语法分析器生成的，用于表示 SQL 查询的逻辑结构，而不是其语法细节。它通过树的节点展示 SQL 查询的各种组成部分及其相互关系，帮助后续的查询优化、执行计划生成等操作。SQL查询语句的AST的构建过程主要分为词法分析：将 SQL 查询字符串转换为一系列tokens;语法分析：将tokens转换成抽象语法树，其中每个节点代表 SQL 查询的一个组成部分。



##### 3.2.3  遍历抽象语法树&生成逻辑执行计划

通过上面的SQL Parser，SQL已经被转为抽象语法树。我们可以使用ANTLR4工具的`Listener`模式，该模式通常需要自定义Listener类继承ANTLR4自动生成的`BaseListener`类，重写其中AST节点处理方法来实现AST遍历时处理逻辑，这样可以在遍历到某个节点时进行特定处理。

我们采用经典的火山模型来设计AST遍历的处理逻辑，该计算模型将关系代数中每一种操作抽象为一个 Operator，将整个 SQL 构建成一个 Operator 树。一般Operator的next() 接口实现分为三步：
（1）调用子节点Operator的next() 接口获取一行数据(tuple)
（2）对tuple进行Operator特定的处理(如filter 或project 等)
（3）返回处理后的tuple。

因此，查询执行时会由查询树自顶向下的调用next() 接口，数据则自底向上的被拉取处理。

 对应的火山模型如下：

![pAyvE8K.png](https://s21.ax1x.com/2024/11/08/pAyvE8K.png)

通过使用ANTLR4工具，对于一个具体的SELECT语句：`SELECT name, age FROM users WHERE age > 30 ORDER BY name;`按照上述流程，得到其AST树为下图：

![pAyvZvD.png](https://s21.ax1x.com/2024/11/08/pAyvZvD.png)

采用`Listener`模式遍历处理AST树得到的对应的逻辑执行计划如下图：

``` java
StmtText                                          			StmtId   NodeId   PhysicalOp             LogicalOp               
-------------------------------------------------------------------------------------------------------------------
SELECT name, age FROM users WHERE age > 30 ORDER BY name;   1        1                                                                                                 
  |--Index Scan (OBJECT: idx_age)                           1        2              Index Scan         Table Access     
  |----Filter (age > 30)                                    1        3              Filter             Filter            
  |----Sort (name)                                          1        4              Sort               Order By           
  |--Output Columns (name, age)                             1        5              Output             Projection          

```







#### 3.3 数据分片支持

#### 3.4 查询分解和优化

本系统基于查询设计中采用的 ANTLR4 解析框架实现，通过查询分解和优化提高 SQL 查询处理的效率和灵活性。查询分解的目的是将复杂的 SQL 查询语句逐步拆解为易于管理的、独立的子部分，便于应用进一步的优化操作，并将其转化为适合数据库执行引擎处理的结构。



​	在查询分解阶段，首先需要定义 SQL 查询的语法规则。这些语法规则由 ANTLR4 定义，并涵盖了 SQL 语句的多种构成要素，包括查询语句的基本结构（如 `SELECT`、`FROM`、`WHERE`、`JOIN` 等）、操作符（如 `=`、`>`、`<` 等）、表达式、连接条件、聚合函数以及排序条件等。通过 ANTLR4 的规则定义，可以确保对 SQL 语句的完整性和语法要求进行约束，并为查询的进一步处理打下基础。

在编写好 SQL 语法规则后，通过 ANTLR4 工具生成语法解析器。该解析器可以将 SQL 查询字符串解析为一个抽象语法树（AST）或解析树，这棵树精确反映了查询语句的结构和层次关系。具体地说，AST 中的每个节点都代表查询语句中的一个组成部分，如选择列、表名称、过滤条件、连接方式等。通过这种结构化表示，系统能够获得查询的详细结构信息，并在此基础上进一步操作。

在 AST 生成后，系统利用 ANTLR4 生成的 Listener 模式遍历解析树。在遍历过程中，系统会逐个分析查询语句中的各个子句和查询元素。例如，`SELECT` 子句可以提供需要查询的列，`FROM` 子句包含数据源表的信息，而 `WHERE` 和 `JOIN` 子句则会定义数据筛选和连接条件。在遍历时，系统可以为每个子句分配适当的处理逻辑，为后续的优化和执行计划生成提供支持。



​	在完成查询分解并生成 AST 后，系统进入查询优化阶段。查询优化的目标是对分解后的各个查询子部分进行分析，应用合适的优化策略，生成更高效的执行计划。在本系统中，优化策略之一是谓词下推，即将 WHERE、JOIN 等子句中的过滤条件尽可能“下推”至查询执行的早期阶段。

谓词下推的核心思想是将尽可能多的过滤操作放到数据源扫描的阶段进行，从而减少中间处理步骤中的数据量。例如，在遍历 AST 时，系统可以识别 `WHERE` 子句中的过滤条件，并尝试将这些条件应用在扫描数据的步骤中。这意味着在数据被加载到内存中或传输到处理器之前，已经通过谓词下推过滤掉了一部分不必要的数据。通过减少不必要的数据传输和计算，谓词下推可以有效地降低查询的执行成本。

具体而言，当遍历解析树中的 `WHERE` 子句或 `JOIN` 条件时，系统会在 AST 中标记并记录这些条件，然后将这些条件在可能的情况下合并到数据读取操作中。这种优化策略对于大数据量查询的性能改进尤为明显。例如，对于索引扫描或分区过滤的情况，谓词下推可以显著减少数据的扫描范围。对于多表连接的情况，下推谓词还可以减少每个表的中间结果，从而降低连接操作的复杂度。



​	在查询分解和优化完成后，系统将基于优化后的 AST 生成 SQL 查询的执行计划。执行计划是一组用于指导数据库如何执行查询的步骤指令，确保系统以最高效的方式处理查询。

执行计划的生成通常包括以下步骤：

1. **扫描阶段**：根据投影下推和谓词下推的结果，系统会选择最优的数据访问方式。例如，尽量使用索引扫描而不是全表扫描，以减少读取的数据量。
2. **过滤阶段**：在数据被加载后立即应用已经下推的谓词条件。由于过滤操作在初期被应用，数据量已经被显著减少。
3. **排序与连接阶段**：如果查询中包含 `ORDER BY` 或连接操作，系统会对筛选结果进行排序和连接操作，这些操作会在数据量较少的基础上进行，进一步提升执行效率。
4. **投影阶段**：最终输出阶段，系统只返回用户所需的列，进一步降低数据处理的复杂度。

对于`SELECT name, age FROM users WHERE age > 30 ORDER BY name`，我们给出了利用ANTLR4工具进行查询分解，以及利用谓词下推进行逻辑优化的详细过程：

根据ANTLR4解析器将整个SQL查询解析为AST树如下：

![pAyvZvD.png](https://s21.ax1x.com/2024/11/08/pAyvZvD.png)



节点 `SELECT`，其子节点分别是：`FROM` 节点，指向数据表 `users`。`SELECT` 列表节点，包括 `name` 和 `age` 两个字段。`WHERE` 条件节点，包含 `age > 30`。`ORDER BY` 节点，指向排序字段 `name`。

优化策略是“谓词下推”，即将 `WHERE` 子句中的过滤条件尽可能地提前到数据读取的早期阶段执行。对于该查询语句，谓词下推的优化过程如下：**识别过滤条件**：

在 AST 中，`WHERE` 子句包含 `age > 30` 的过滤条件。该条件是一个谓词，作用是筛选 `users` 表中符合条件的记录。**下推过滤条件**：在生成执行计划时，系统会尽可能将 `WHERE age > 30` 的过滤条件下推到 `users` 表的扫描阶段。通过下推过滤条件，系统可以在读取数据时直接筛选掉不符合 `age > 30` 的记录，避免将不必要的数据传输到后续的处理阶段。

基于上面的优化，以下是该 SQL 查询的执行计划：



```java
StmtText                                          StmtId  NodeId  Parent  PhysicalOp            LogicalOp             Description
---------------------------------------------------------------------------------------------------------------
SELECT name, age FROM users WHERE age > 30 ORDER BY name 1       1       NULL    SELECT               SELECT                                    
`--Table Scan`                                    1       2       1       Table Scan           Table Access                           
`--Filter`                                        1       3       2       Filter               Filter                                 
`--Projection`                                    1       4       3       Projection           Projection                             
`--Sort`                                          1       5       4       Sort                 Order By                               

```

优化后的执行计划解析：**Table Scan**：系统对 `users` 表进行扫描，由于在 `WHERE` 条件中有 `age > 30`，过滤条件被下推到扫描阶段。在数据读取时，仅将满足 `age > 30` 的记录读入系统，减少后续的处理数据量。**Filter**：在表扫描的过程中，系统应用了 `age > 30` 的过滤条件。这一步在早期就减少了数据量，避免了不必要的数据传输。**Projection**：完成过滤后，系统仅输出 `name` 和 `age` 两个字段，丢弃其他无关数据，进一步优化了数据处理的效率。**Sort**：在所有筛选完成后，系统对结果集进行排序。排序操作在数据量较少的基础上进行，减少了排序所需的资源。



通过上述流程，查询语句在分解和优化过程中减少了数据传输：在扫描阶段下推过滤条件，确保仅读取和处理符合条件的数据。降低内存占用：过滤条件和投影在早期应用，避免不必要的字段传输和数据量。加速排序操作：排序在数据量减少后进行，优化了排序的速度和内存开销。这种优化策略提高了查询的执行效率，降低了系统负载，并确保了在处理大数据量查询时能够快速响应。





