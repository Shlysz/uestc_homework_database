# 小型分布式图书馆系统的数据库系统

### 一.需求分析

1. **数据存储要求**
   - 数据必须存储在至少3个物理站点上，以确保数据的高可用性和容错性。
   - 数据的存储和分布方式对用户完全透明，不会影响用户的操作和体验。
2. **查询支持**
   - 系统支持基本的SQL查询语句，重点支持CRUD（创建、读取、更新、删除）等基本操作。
   - 系统不强制支持嵌套查询语句，专注于常用的简单SQL语句的执行。
   - 查询结果应能够实时反映到用户界面，确保用户可以及时获取查询结果。
3. **数据分片支持**
   - 系统支持多种数据划分方式：
     - **水平划分**：根据行数据的不同范围将数据划分到不同站点。
     - **垂直划分**：根据列属性划分数据。
     - **水平 + 垂直混合划分**：组合水平和垂直划分的方式。
     - **混合划分**：灵活支持其他划分策略，以满足特定场景需求。
   - 系统可以根据实际需求，灵活选择或调整数据的分布方式，以提高查询效率和系统性能。
4. **查询分解与优化**
   - 用户的查询请求必须经过解析与优化，并分解成可分布执行的子任务。
   - 优化后的查询会下发给底层数据库管理系统进行分布式执行，以提高查询的性能和准确性。
5. **分站点服务器界面**
   - 各分站点服务器的界面上必须实时显示接收和发送的SQL命令，直观展示命令的执行过程。
   - 命令的执行结果和处理过程直接在界面显示，不允许将这些信息记录到日志文件中，以确保信息的实时性和可视化。
6. **主站点界面**
   - 主站点界面应显示用户查询的分解和优化过程，确保用户可以直观了解查询的执行流程。
   - 主站点同时承担系统协调和调度的任务，提供对查询优化过程的实时反馈。

### 二.



### 1. **系统架构设计**

**组件**：

- **主站点服务器**：负责协调和管理整个系统的查询请求、分解和优化；负责向各分站点派发子查询并收集处理结果。
- **分站点服务器**：至少包含3个分站点，用于存储数据并执行主站点下发的子查询。

**基本流程**：

- 用户在主站点提交查询请求（例如，查询、插入、更新、删除操作）。
- 主站点解析查询并进行优化，将查询拆解成分站点可以处理的子查询。
- 分站点接收并处理子查询，将结果返回主站点。
- 主站点整合并展示最终结果给用户，同时在界面上展示每步处理的细节。

### 2. **数据划分**

### 3. **基本SQL查询支持**

- 为了支持用户的基本 SQL 查询（例如 `SELECT`、`INSERT` 等），解析SQL查询语句是必须的，SQL解析功能是数据库管理系统（DBMS）中的一个关键组件，它负责解释和分析用户提交的SQL（Structured Query Language）查询语句，通过SQL解析，DBMS能够理解用户的请求并执行相应的操作，如查询、插入、更新或删除数据。

  1. **理解查询意图** 

  - 解析 SQL 语句的首要目的是理解用户的查询意图，即了解用户希望从数据库中提取哪些信息。通过解析 SQL，可以将用户的自然语言式查询转换为数据库系统可以理解和处理的结构。
  - 例如：解析 `SELECT name FROM users WHERE age > 18;` 可以帮助系统理解，用户希望从 `users` 表中检索 `name` 列中 `age` 大于 `18` 的数据。

  2. **检查SQL语法的正确性**

  - 解析过程能够检测 SQL 语句的语法错误。如果用户的查询语句中存在拼写错误或格式错误，解析器会在执行前捕获这些错误，并向用户返回明确的错误信息。

  3. **生成逻辑执行计划**

  - SQL 解析后可以生成一个逻辑执行计划，展示查询语句的执行步骤。这对于优化查询性能至关重要。通过解析语句，可以分解查询的各个部分（如 `SELECT`、`FROM`、`WHERE`），并安排最优的执行顺序。
  - 例如：在执行复杂查询时，系统可以决定先进行过滤操作（`WHERE`）再做连接（`JOIN`），从而减少数据处理量。

  4. **支持查询优化**

  - 解析 SQL 查询后，可以应用优化策略，如索引优化、子查询展开、表达式简化等。这些优化可以提升查询的执行效率，减少资源消耗，尤其在处理大数据时更为关键。
  - 例如：将 `SELECT * FROM employees WHERE department = 'HR' AND salary > 50000;` 优化为使用索引检索 `department` 列中的 `HR` 值，从而减少查询耗时。

- 当前



### 7. **多种数据库兼容**

- SQL 解析支持多种数据库的 SQL 方言，能够使系统适配不同数据库，扩展其可移植性。不同数据库对 SQL 语法的支持略有差异，解析器可以帮助处理这些差异，使查询适用于不同的数据库引擎。

- 例如：MySQL 和 PostgreSQL 对某些 SQL 语法的支持不同，解析器可以帮助系统适配这些差异。

- ANTLR4 解析 SQL 语句，提取查询结构和关键信息。这些信息用于后续的查询分解和优化。

- 传统的SQL查询，依赖完整的数据库协议。比如在MySQL、Oracle等中，有标准的SQL语法。我们可以通过不同的SQL语句来实现业务需求，我们使用了ANTLR4的SQL解析器实现SQL语句查询。

- Antlr4 是一款强大的语法生成器工具，可用于读取、处理、执行和翻译结构化的文本或二进制文件。基本上是当前 Java 语言中使用最为广泛的语法生成器工具。Twitter搜索使用ANTLR进行语法分析，每天处理超过20亿次查询；Hadoop生态系统中的Hive、Pig、数据仓库和分析系统所使用的语言都用到ANTLR；Lex Machina将ANTLR用于分析法律文本；Oracle公司在SQL开发者IDE和迁移工具中使用了ANTLR；NetBeans公司的IDE使用ANTLR来解析C++；Hibernate对象-关系映射框架（ORM）使用ANTLR来处理HQL语言。

- 使用ANTLR来实现一条SQL，执行或者实现的过程大致是这样的，实现词法文件（.g4），生成词法分析器和语法分析器，生成抽象语法树（也就是我常说的AST），然后再遍历抽象语法树，生成语义树，访问统计信息，优化器生成逻辑执行计划，再生成物理执行计划去执行。

  ![image-20241103192227864](C:\Users\zlf\AppData\Roaming\Typora\typora-user-images\image-20241103192227864.png)



#### 使用 ANTLR4 进行 SQL 解析

1. Parser是用来识别语言的程序，其本身包含两个部分：词法分析器和语法分析器。词法分析阶段主要解决的问题是关键字以及各种标识符，比如INT（类型关键字）和ID（变量标识符）。语法分析主要是基于词法分析的结果，构造一颗语法分析树，流程大致如下：

   ![image-20241103192502600](C:\Users\zlf\AppData\Roaming\Typora\typora-user-images\image-20241103192502600.png)

   因此，为了让词法分析和语法分析能够正常工作，在使用ANTLR4的时候，需要定义语法（Grammar）。

   我们可以把字符流（CharStream），转换成一棵语法分析树，字符流经过词法分析会变成Token流。Token流再最终组装成一棵语法分析树，其中包含叶子节点（TerminalNode）和非叶子节点（RuleNode）。具体语法分析树如下图所示：

   ![image-20241104142227136](C:\Users\zlf\AppData\Roaming\Typora\typora-user-images\image-20241104142227136.png)

2. **定义 SQL 语法文件**
   ANTLR官方提供了很多常用的语言的语法文件，这里我们复用了Mysql官方的sql语法文件。使用Java中插件ANTLR4解析sql查询语句得到AST树；

   ![image-20241104144331347](C:\Users\zlf\AppData\Roaming\Typora\typora-user-images\image-20241104144331347.png)

3. **生成解析器和词法器**
   使用 ANTLR4 生成 `SQLLexer` 和 `SQLParser`，在 Java 中应用这些类来解析用户输入的 SQL 语句。

4. **定义SQLnode**

   定义AST抽象树Node，包括Expression，Relation，Statement,SelectItem等，具体如下所示：

   ![image-20241104144648912](C:\Users\zlf\AppData\Roaming\Typora\typora-user-images\image-20241104144648912.png)

5. **实现生成逻辑执行计划**
   通过上面的SQL Parser，SQL已经被转为SQL Node。作为一个数据查询完整流程，我们采用经典的火山模型，该计算模型将关系代数中每一种操作抽象为一个 Operator，将整个 SQL 构建成一个 Operator 树。一般Operator的next() 接口实现分为三步：
   （1）调用子节点Operator的next() 接口获取一行数据(tuple)
   （2）对tuple进行Operator特定的处理(如filter 或project 等)
   （3）返回处理后的tuple。

   因此，查询执行时会由查询树自顶向下的调用next() 接口，数据则自底向上的被拉取处理。
   ![image-20241104145351397](C:\Users\zlf\AppData\Roaming\Typora\typora-user-images\image-20241104145351397.png)

    对应的火山模型如下：

   ![image-20241104145430226](C:\Users\zlf\AppData\Roaming\Typora\typora-user-images\image-20241104145430226.png)

### 4. **分布式查询执行流程**

- 主站点在分解查询后，将子查询派发到各个分站点。每个分站点单独执行接收到的子查询并返回结果。具体过程如下：
  1. **主站点分发子查询**
     主站点生成子查询并将其分发至相应的分站点。例如，主站点将 `SELECT Title, Author FROM Books WHERE Genre = 'Science Fiction'` 派发到 `分站点A`。
  2. **分站点执行并返回结果**
     各分站点的数据库接收到查询请求，在本地执行查询，并将结果返回给主站点。例如，`分站点A` 返回 `[Title: The Martian, Author: Andy Weir], [Title: Dune, Author: Frank Herbert]`。
  3. **分站点显示查询日志**
     根据需求，每个分站点在界面上实时显示执行的查询命令和处理结果，而非写入日志文件。这样可以直接在界面上监控到各个分站点接收到的请求。

### 5. 结果整合与展示

主站点接收到各分站点返回的结果后，将所有子查询的结果整合，并将最终查询结果返回给用户界面。

1. **整合子查询结果**
   将分站点的查询结果汇总后，形成完整的查询响应。例如，将来自 `分站点A` 的结果和其他可能分片的结果组合成最终的结果集。
2. **结果展示**
   最终结果在主站点界面上展示，并显示查询的分解和分发过程，以便用户理解查询的执行流程。