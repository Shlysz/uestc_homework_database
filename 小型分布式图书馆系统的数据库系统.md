# 小型分布式图书馆系统的数据库系统

### 一.需求分析

1. **数据存储要求**
   - 数据必须存储在至少3个物理站点上，以确保数据的高可用性和容错性。
   - 数据的存储和分布方式对用户完全透明，不会影响用户的操作和体验。
2. **查询支持**
   - 系统支持基本的SQL查询语句，重点支持CRUD（创建、读取、更新、删除）等基本操作。
   - 系统不强制支持嵌套查询语句，专注于常用的简单SQL语句的执行。
   - 查询结果应能够实时反映到用户界面，确保用户可以及时获取查询结果。
3. **数据分片支持**
   - 系统支持多种数据划分方式：
     - **水平划分**：根据行数据的不同范围将数据划分到不同站点。
     - **垂直划分**：根据列属性划分数据。
     - **水平 + 垂直混合划分**：组合水平和垂直划分的方式。
     - **混合划分**：灵活支持其他划分策略，以满足特定场景需求。
   - 系统可以根据实际需求，灵活选择或调整数据的分布方式，以提高查询效率和系统性能。
4. **查询分解与优化**
   - 用户的查询请求必须经过解析与优化，并分解成可分布执行的子任务。
   - 优化后的查询会下发给底层数据库管理系统进行分布式执行，以提高查询的性能和准确性。
5. **分站点服务器界面**
   - 各分站点服务器的界面上必须实时显示接收和发送的SQL命令，直观展示命令的执行过程。
   - 命令的执行结果和处理过程直接在界面显示，不允许将这些信息记录到日志文件中，以确保信息的实时性和可视化。
6. **主站点界面**
   - 主站点界面应显示用户查询的分解和优化过程，确保用户可以直观了解查询的执行流程。
   - 主站点同时承担系统协调和调度的任务，提供对查询优化过程的实时反馈。

### 二. 系统结构设计

#### 2.1 总体设计

​	本系统采用Java 17编写，并基于Spring Boot框架实现分布式通信，通过HTTP协议实现各站点之间的交互。系统使用B+树作为数据存储结构，主站点和各分站点均独立维护本地的B+树，以实现数据的高效存储与快速检索。查询请求首先由主站点接收并解析，主站点利用全局索引将请求分解为子查询，然后通过Spring Boot的HTTP接口将子查询分发到相应分站点。
​	在各分站点中，Spring Boot的Controller组件负责接收并处理主站点发来的HTTP请求，调用本地B+树进行数据操作，并将结果通过HTTP返回给主站点。主站点负责汇总各分站点的结果并返回给用户，从而实现透明、快速的分布式数据查询。


#### 2.2 数据存储设计
本系统采用B+树作为底层数据存储结构，利用其高效的检索和范围查询能力，实现对大规模有序数据的管理。B+树的叶子节点存储实际数据，并按顺序相连，适合快速的范围查询操作。在分布式环境中，数据根据B+树的键值范围进行分片，分布在多个站点的本地B+树中，各站点各自维护本地B+树的结构与索引。
	在分布式架构中，通过HTTP协议在站点之间进行通信，主站点负责全局索引的管理及查询请求的路由。用户查询请求在主站点通过全局B+树索引解析后，拆分成多个子查询，并由HTTP请求发送至相关分站点进行处理。各分站点基于本地B+树结构独立执行查询，返回结果至主站点汇总。主站点还负责协调各站点间的数据一致性与故障恢复，确保分布式系统的高可用性和数据可靠性。

#### 2.3 查询设计

### 2.4 数据分片支持

#### 2.5查询分解和优化

#### 2.6界面设计

### 三. 详细设计

### 3.1 数据存储结构设计







### 1. **系统架构设计**

**组件**：

- **主站点服务器**：负责协调和管理整个系统的查询请求、分解和优化；负责向各分站点派发子查询并收集处理结果。
- **分站点服务器**：至少包含3个分站点，用于存储数据并执行主站点下发的子查询。

**基本流程**：

- 用户在主站点提交查询请求（例如，查询、插入、更新、删除操作）。
- 主站点解析查询并进行优化，将查询拆解成分站点可以处理的子查询。
- 分站点接收并处理子查询，将结果返回主站点。
- 主站点整合并展示最终结果给用户，同时在界面上展示每步处理的细节。

### 2. **数据划分**

### 3. **基本SQL查询支持**

- 为了支持用户的基本 SQL 查询（例如 `SELECT`、`INSERT` 等），我们使用 ANTLR4 解析 SQL 语句，提取查询结构和关键信息。这些信息用于后续的查询分解和优化。

- 传统的SQL查询，依赖完整的数据库协议。比如在MySQL、Oracle等中，有标准的SQL语法。我们可以通过不同的SQL语句来实现业务需求，我们使用了ANTLR4的SQL解析器实现SQL语句查询。

- Antlr4 是一款强大的语法生成器工具，可用于读取、处理、执行和翻译结构化的文本或二进制文件。基本上是当前 Java 语言中使用最为广泛的语法生成器工具。Twitter搜索使用ANTLR进行语法分析，每天处理超过20亿次查询；Hadoop生态系统中的Hive、Pig、数据仓库和分析系统所使用的语言都用到ANTLR；Lex Machina将ANTLR用于分析法律文本；Oracle公司在SQL开发者IDE和迁移工具中使用了ANTLR；NetBeans公司的IDE使用ANTLR来解析C++；Hibernate对象-关系映射框架（ORM）使用ANTLR来处理HQL语言。

- 使用ANTLR来实现一条SQL，执行或者实现的过程大致是这样的，实现词法文件（.g4），生成词法分析器和语法分析器，生成抽象语法树（也就是我常说的AST），然后再遍历抽象语法树，生成语义树，访问统计信息，优化器生成逻辑执行计划，再生成物理执行计划去执行。

  ![image-20241103192227864](C:\Users\zlf\AppData\Roaming\Typora\typora-user-images\image-20241103192227864.png)



#### 使用 ANTLR4 进行 SQL 解析

1. Parser是用来识别语言的程序，其本身包含两个部分：词法分析器和语法分析器。词法分析阶段主要解决的问题是关键字以及各种标识符，比如INT（类型关键字）和ID（变量标识符）。语法分析主要是基于词法分析的结果，构造一颗语法分析树，流程大致如下：

   ![image-20241103192502600](C:\Users\zlf\AppData\Roaming\Typora\typora-user-images\image-20241103192502600.png)

   因此，为了让词法分析和语法分析能够正常工作，在使用ANTLR4的时候，需要定义语法（Grammar）。

   我们可以把字符流（CharStream），转换成一棵语法分析树，字符流经过词法分析会变成Token流。Token流再最终组装成一棵语法分析树，其中包含叶子节点（TerminalNode）和非叶子节点（RuleNode）。具体语法分析树如下图所示：

   ![image-20241104142227136](C:\Users\zlf\AppData\Roaming\Typora\typora-user-images\image-20241104142227136.png)

2. **定义 SQL 语法文件**
   ANTLR官方提供了很多常用的语言的语法文件，这里我们复用了Mysql官方的sql语法文件。使用Java中插件ANTLR4解析sql查询语句得到AST树；

   ![image-20241104144331347](C:\Users\zlf\AppData\Roaming\Typora\typora-user-images\image-20241104144331347.png)

3. **生成解析器和词法器**
   使用 ANTLR4 生成 `SQLLexer` 和 `SQLParser`，在 Java 中应用这些类来解析用户输入的 SQL 语句。

4. **定义SQLnode**

   定义AST抽象树Node，包括Expression，Relation，Statement,SelectItem等，具体如下所示：

   ![image-20241104144648912](C:\Users\zlf\AppData\Roaming\Typora\typora-user-images\image-20241104144648912.png)

5. **实现生成逻辑执行计划**
   通过上面的SQL Parser，SQL已经被转为SQL Node。作为一个数据查询完整流程，我们采用经典的火山模型，该计算模型将关系代数中每一种操作抽象为一个 Operator，将整个 SQL 构建成一个 Operator 树。一般Operator的next() 接口实现分为三步：
   （1）调用子节点Operator的next() 接口获取一行数据(tuple)
   （2）对tuple进行Operator特定的处理(如filter 或project 等)
   （3）返回处理后的tuple。

   因此，查询执行时会由查询树自顶向下的调用next() 接口，数据则自底向上的被拉取处理。
   ![image-20241104145351397](C:\Users\zlf\AppData\Roaming\Typora\typora-user-images\image-20241104145351397.png)

    对应的火山模型如下：

   ![image-20241104145430226](C:\Users\zlf\AppData\Roaming\Typora\typora-user-images\image-20241104145430226.png)

### 4. **分布式查询执行流程**

- 主站点在分解查询后，将子查询派发到各个分站点。每个分站点单独执行接收到的子查询并返回结果。具体过程如下：
  1. **主站点分发子查询**
     主站点生成子查询并将其分发至相应的分站点。例如，主站点将 `SELECT Title, Author FROM Books WHERE Genre = 'Science Fiction'` 派发到 `分站点A`。
  2. **分站点执行并返回结果**
     各分站点的数据库接收到查询请求，在本地执行查询，并将结果返回给主站点。例如，`分站点A` 返回 `[Title: The Martian, Author: Andy Weir], [Title: Dune, Author: Frank Herbert]`。
  3. **分站点显示查询日志**
     根据需求，每个分站点在界面上实时显示执行的查询命令和处理结果，而非写入日志文件。这样可以直接在界面上监控到各个分站点接收到的请求。

### 5. 结果整合与展示

主站点接收到各分站点返回的结果后，将所有子查询的结果整合，并将最终查询结果返回给用户界面。

1. **整合子查询结果**
   将分站点的查询结果汇总后，形成完整的查询响应。例如，将来自 `分站点A` 的结果和其他可能分片的结果组合成最终的结果集。
2. **结果展示**
   最终结果在主站点界面上展示，并显示查询的分解和分发过程，以便用户理解查询的执行流程。