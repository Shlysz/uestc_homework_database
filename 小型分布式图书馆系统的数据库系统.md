# 小型分布式图书馆系统的数据库系统

### 一.需求分析

1. **数据存储要求**
   - 数据必须存储在至少3个物理站点上，以确保数据的高可用性和容错性。
   - 数据的存储和分布方式对用户完全透明，不会影响用户的操作和体验。
   
2. **查询支持**
   - 系统支持基本的SQL查询语句，重点支持CRUD（创建、读取、更新、删除）等基本操作。
   - 系统不强制支持嵌套查询语句，专注于常用的简单SQL语句的执行。
   - 查询结果应能够实时反映到用户界面，确保用户可以及时获取查询结果。
   
3. **数据分片支持**
   
   - 系统支持多种数据划分方式：
     - **水平划分**：根据行数据的不同范围将数据划分到不同站点。
     
     - **垂直划分**：根据列属性划分数据。
     
       系统可以根据实际需求，灵活选择或调整数据的分布方式，以提高查询效率和系统性能。
   
4. **查询分解与优化**
   - 用户的查询请求必须经过解析与优化，并分解成可分布执行的子任务。
   - 优化后的查询会下发给底层数据库管理系统进行分布式执行，以提高查询的性能和准确性。
   
5. **分站点服务器界面**
   - 各分站点服务器的界面上必须实时显示接收和发送的SQL命令，直观展示命令的执行过程。
   - 命令的执行结果和处理过程直接在界面显示，不允许将这些信息记录到日志文件中，以确保信息的实时性和可视化。
   
6. **主站点界面**
   - 主站点界面应显示用户查询的分解和优化过程，确保用户可以直观了解查询的执行流程。
   - 主站点同时承担系统协调和调度的任务，提供对查询优化过程的实时反馈。

### 二. 系统结构设计

#### 2.1 总体设计

​	本系统采用Java 17编写，并基于Spring Boot框架实现分布式通信，通过HTTP协议实现各站点之间的交互。系统使用B+树作为数据存储结构，主站点和各分站点均独立维护本地的B+树，以实现数据的高效存储与快速检索。查询请求首先由主站点接收并解析，主站点利用全局索引将请求分解为子查询，然后通过Spring Boot的HTTP接口将子查询分发到相应分站点。
​	在各分站点中，Spring Boot的Controller组件负责接收并处理主站点发来的HTTP请求，调用本地B+树进行数据操作，并将结果通过HTTP返回给主站点。主站点负责汇总各分站点的结果并返回给用户，从而实现透明、快速的分布式数据查询。


#### 2.2 数据存储设计
本系统采用B+树作为底层数据存储结构，利用其高效的检索和范围查询能力，实现对大规模有序数据的管理。B+树的叶子节点存储实际数据，并按顺序相连，适合快速的范围查询操作。在分布式环境中，数据根据B+树的键值范围进行分片，分布在多个站点的本地B+树中，各站点各自维护本地B+树的结构与索引。
	在分布式架构中，通过HTTP协议在站点之间进行通信，主站点负责全局索引的管理及查询请求的路由。用户查询请求在主站点通过全局B+树索引解析后，拆分成多个子查询，并由HTTP请求发送至相关分站点进行处理。各分站点基于本地B+树结构独立执行查询，返回结果至主站点汇总。主站点还负责协调各站点间的数据一致性与故障恢复，确保分布式系统的高可用性和数据可靠性。

#### 2.3 查询设计

#### 2.4 数据分片支持

本系统在水平划分中采用一致性哈希算法，将数据均匀分布在多个站点上。每个站点通过哈希环的方式定位数据位置，避免了新增或移除节点时的大量数据迁移，从而提升系统的扩展性和负载均衡效果。在垂直划分方面，系统对表结构进行简单分割，将主键和其他字段分成三段，每段均包含主键分别存储到不同的分片中，便于基于主键的快速查找和关联查询。

#### 2.5查询分解和优化



#### 2.6界面设计

由于演示，本系统只设计了命令行界面，同时分站点的命令行界面设置输出日志，打印具体操作信息，主站点只展示增删查改的结果。

### 三. 详细设计

#### 3.1 数据存储结构设计

##### 3.1.1 B+树的设计

 在B+树的设计上，定义B+树的数据结构`bPlusTree`、`bPlusNode`定义B+树，其中bPlusNode是存储节点，存储数据。在本系统中，B+树的节点被设计为存储数据的基本单元，每个节点有两个主要部分：键值和指向子节点的指针。每个叶子节点包含实际的数据记录，所有叶子节点通过链表连接，形成一个顺序结构，支持快速的范围查询和顺序扫描。内部节点仅用于索引，其主要作用是根据键值快速定位数据位置，因此它们不存储实际的数据记录。
B+树的根节点初始时为叶子节点，当节点达到设定的最大容量时，将会发生节点分裂操作，并将中间键值提升到父节点中，从而保持树的平衡性。通过这种结构，B+树能够在查询、插入和删除时保持较低的时间复杂度，适合用于大规模数据的存储和快速访问。

对B+树采用泛型编程，以便实现对不同类型的键和数据的存储。
具体数据结构如下：

```java
public class BPlusTree<K extends Comparable<K>, V> {
    // 根节点
    protected BPlusNode<K, V> root;
    // 阶数，M值
    protected int order;
    // 叶子节点的链表头
    protected BPlusNode<K, V> head;
    // 树高
    protected int height = 0;
}
public class BPlusNode<K extends Comparable<K>, V> {
    // 是否为叶子节点
    protected boolean isLeaf;
    // 是否为根节点
    protected boolean isRoot;
    // 父节点
    protected BPlusNode<K, V> parent;
    // 叶节点的前节点
    protected BPlusNode<K, V> previous;
    // 叶节点的后节点
    protected BPlusNode<K, V> next;
    // 节点的关键字列表
    protected List<Map.Entry<K, V>> entries;
    // 子节点列表
    protected List<BPlusNode<K, V>> children;
}
```
##### 3.1.2 索引设计

在索引的设计中，引入`TableMap`类，索引功能通过 `indexTreeHashMap` 进行管理，`indexTreeHashMap` 是一个 `HashMap`，它的键是表中用于索引的列名（即字段名），值是相应列的索引树。每个索引树（`IndexTree<K, V>`）基于B+树实现，允许高效地对指定字段进行索引查找。B+树索引结构能够支持快速的范围查询、精确查询及排序操作，尤其适合于需要高效访问和排序的大规模数据集。
通过将不同字段的索引存储在 `indexTreeHashMap` 中，系统可以根据查询需要灵活选择合适的索引字段，从而优化查询性能。每个 `IndexTree` 对应着一个字段的B+树索引，`K` 表示索引字段的数据类型，`V` 则表示与该字段相关的数据记录（例如对应的主键值或者其他信息）。当执行查询操作时，系统可以根据查询条件快速访问相应的索引树，跳过全表扫描，从而提升查询效率。
此外，`columnConstraint` 用于存储列的约束条件（如主键、外键、唯一性等），这些约束可以在创建索引时考虑进来，确保数据一致性和完整性。通过这种设计，`TableMap` 不仅能够有效管理表的列信息和数据记录，还能提供灵活且高效的索引机制来加速数据查询。
具体的数据结构如下：
```java
public class TableMap<K extends Comparable<K>, V> {
    private String name;//表名
    private String[] columns;//表的列名
    private String[] columnType;//表的列的类型
    HashMap<String, String> columnConstraint;
    //表的b+树的索引关系，string记录了表是按照哪个字段进行索引的
    HashMap<String, IndexTree<K, V>> indexTreeHashMap;
}
```
#### 3.2 数据分片

数据分片是指将数据库中的数据按照一定规则拆分并分布到多个节点上，以提高数据的存储和访问效率。在本系统中，数据分片依赖于分片算法和元数据的管理，通过 `MetaData` 类来记录数据库的基本信息和节点信息。在当前实现中，数据分片采用哈希值取模的方式进行，尤其适用于节点数量较少的场景。下面将详细描述水平分片和一致性哈希的设计。
##### 3.2.1 水平分片
在当前系统设计中，为了进行水平分片，首先需要确定如何将数据的不同部分分布到不同的节点。为了简化设计，采用了基于哈希值取模的分片算法。`MetaData` 类中的 `getIP` 方法便是实现分片逻辑的核心。它接收一个 `key`（可以是数据记录的主键或者其他可哈希字段），首先通过 `key.hashCode()` 计算一致性哈希的值，得到一个索引，最后返回相应节点的IP地址和端口信息。根据这一分片策略，数据的每一行会根据哈希值均匀分布到不同的节点上。

具体数据结构如下：

```java
public class MetaData {//记录库的元数据
    private final String name;//库名
    private final String[] tables;//库的表名
    //节点信息，这里有三个节点，形成按照行分片的分布式数据库
    String[] nodeIPs;//三个节点的ip
    String[] nodePorts;//三个节点的端口
}
```

##### 3.2.2 垂直分片

垂直分片的计算逻辑较为简单，直接将数据库的库的表的字段按照三份平均分开，也就是分成三个表，每个表均带有，然后按照对主键和第二个键的方法进行一致性哈希运算，得出将每个表存到哪个节点。

#### 3.3 分布式设计

在使用Spring Boot框架设计数据库逻辑执行计划的HTTP请求URL时，我们遵循了RESTful API设计原则，将操作类型和资源路径清晰地映射到数据库操作上。首先，对于查询操作，设计为`GET /api/database/{db_name}/table/{table_name}/select`/from={字段}&where={字段}，此路径允许通过查询参数传递字段、过滤条件、排序、分页等信息。插入操作通过`POST /api/database/{db_name}/table/{table_name}/insert`进行，传递的数据字段和值作为请求体。更新操作则使用`PUT /api/database/{db_name}/table/{table_name}/update`，同样通过查询参数指定筛选条件，并通过请求体传递要更新的字段和值。删除操作使用`DELETE /api/database/{db_name}/table/{table_name}/delete`，通过查询参数提供删除条件。
这种设计结构确保了每个请求都能够映射到一个明确的数据库操作，并且通过URL中的参数和请求体传递必要的信息，从而实现灵活和可扩展的数据库交互。通过Spring Boot的Controller层，我们可以将这些请求映射到相应的服务层处理逻辑，完成相应的数据库操作。

### 四. 结果展示



### 五. 总结与反思

小型分布式图书馆系统的数据库设计采用了B+树作为底层数据存储结构，确保高效的检索、插入和删除操作，特别适合大规模有序数据的管理。同时，系统实现了基于一致性哈希算法的水平分片和简单的主键平分垂直分片，保证了数据的均匀分布和容错能力。在请求处理方面，使用Spring Boot框架和HTTP协议设计了RESTful API接口，支持增、删、改、查等操作，并通过清晰的URL和参数传递查询逻辑，使得系统具备了良好的灵活性和扩展性，能够高效处理图书馆的业务需求。
但是，本系统仍有不足之处：
1. 仅对数据的水平分布做了详细设计，而垂直分布的考虑欠佳。
1. 在数据的存储方面，仅仅模拟了B+树的存储，而没有正真实现数据的持久化。
1. 显然使用RPC来进行各站点的通信更加有效率，使用http协议略显臃肿。
1. 